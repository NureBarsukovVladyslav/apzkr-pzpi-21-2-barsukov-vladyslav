Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для оптимізації роботи волонтерських організацій у кризових ситуаціях.

Студент гр. ПЗПІ-21-2	_______________ Барсуков В. О.
(підпис)
Керівник роботи	__________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р.
 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6				____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Барсукову Владиславу Олександровичу
1.	Тема роботи: «Програмна система для оптимізації роботи волонтерських організацій у кризових ситуаціях»	
2.	Термін узгодження завдання курсової роботи «25» березня 2024 р.
3.	Термін здачі студентом закінченої роботи «15» червня 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
комунікація,  автоматизоване управління завданнями, моніторинг, звітність, управління ресурсами, адаптивний інтерфейс, інтеграції з волонтерськими організаціями, реалізація двох компонентів (Back-end, Front-end)	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування бази даних, архітектура програмної системи, опис програмної системи, висновки, перелік джерел посилання, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень), ER-діаграма, схема бази даних, UML-діаграма серверної частини, UML-діаграма пакетів, UML-діаграма розгортання, UML-діаграма клієнтської частини, UML-діаграма пакетів клієнтської частини	
 
КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проєкту	31.03.2024	
2	Проєктування програмного
проєкту	15.04.2024	
3	Кодування програмного проєкту	01.06.2024	
4	Оформлення пояснювальної
записки	14.06.2024	
5	Захист курсової роботи	15.06.2024	

Дата видачі завдання «24» березня 2024 р.
Керівник	_________________ доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	_________________            Барсуков В. О.
(підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 91 с., 16 рис., 3 додатки, 2 табл., 7 джерел. 
ВОЛОНТЕР, ПОСТРАЖДАЛИЙ, РЕСУРСИ, КООРДИНАЦІЙНИЙ ЦЕНТР, ПІДТРИМКА, ЧАТ, ДОБРОВОЛЕЦЬ, СТАТУС, ВІДДІЛ.
Предметом дослідження є область управління волонтерськими організаціями під час кризових ситуацій, розробка програмної системи для автоматизації процесів координації, комунікації та аналізу даних.
Метою цього курсового проекту є створення програмної системи, яка спрощує координацію та управління волонтерськими організаціями пiд час надзвичайних ситуацiй. Ця система надасть можливостi створювати та управляти завданнями, автоматично розподiляти завдання мiж волонтерами, контролювати їх виконання, забезпечить комунiкацiю мiж волонтерами i постраждалими, збиратиме та аналiзуватиме данi про виконанi завдання.
Мевтодика розробки ґрунтується на застосуваннi сучасних технологiй для створення серверної тa клієнтської частини системи.
У результаті розроблено програмну системy, яка полегшyє управління волонтepами пiд час кpизових ситyаций, oптyмізує коopдинaцію дій, зaбeзпечyє ефeктивне викopистaння pесypсiв і забезпечує допомогу потеpпілим.

 
ЗМІСТ
	

ВСТУП	7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1 Бізнес-вимоги	8
1.1.1 Бізнес-можливості	8
1.1.2 Бізнес-цілі та критерії успіху	8
1.1.3 Потреби клієнтів та ринку	10
1.1.4 Бізнес-ризики	12
1.2 Концепція рішення	12
1.2.1 Окреслення концепції	12
1.2.2 Головна функціональність	13
1.2.3 Припущення та залежності	14
1.3 Рамки та обмеження проєкту	16
1.3.1 Рамки первинного випуску	16
1.3.2 Рамки наступних випусків	16
1.3.3 Обмеження та винятки	17
1.4 Бізнес-контекст	18
1.4.1 Профілі зацікавлених сторін	18
1.4.2 Пріоритети проєкту	20
1.4.3 Робоче середовище	20
2 ПОСТАНОВКА ЗАДАЧІ	22
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ	24
3.1 Побудова ER-діаграми	24
3.2 Побудова логічної моделі бази даних на основі ER-діаграми	25
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	33
4.1 Архітектура серверної частини	33
4.2 Архітектура клієнтської частини	37
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ	44
5.1 Виклик і завантаження	44
5.2 Логічна структура програмної системи	45
5.3 Опис користувацького інтерфейсу	46
ВИСНОВКИ	54
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	55
ДОДАТОК A	56
Код серверної частини	56
ДОДАТОК Б	67
Код клієнтської частини	67

 
ВСТУП


Головною метою організацій, що працюють на волонтерських засадах, є надання допомоги людям під час надзвичайних ситуацій. Волонтерська робота потребує значних зусиль та ресурсів. Тому велика потреба у високоякісній програмній системі, яка допоможе ефективно керувати всіма волонтерськими організаціями під час кризових ситуацій.
Для успішного управління завданнями волонтерства необхідно враховувати багато ключових аспектів, таких як місцезнаходження постраждалих і волонтерів, пріоритетність завдання, навички волонтерa тощо. Програмне забезпечення може одночасно контролювати всi цi параметри - у цьому його перевага перед людиною.
Ця програмна система розроблена з метою забезпечення бiльш сучасного тa комфортного пiдходу до управлiння. Вона дасть можливость користувачам контролювати процеси та локацiй, сприятиме отриманню необхiдних даних для своєчасного надання допомоги постраждалим. 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


Ринкові аналоги:
	Crisis Cleanup: система спеціалізується на організації та координації волонтерської допомоги під час надзвичайних ситуацій. Вона надає можливості створення завдань та їх автоматичного розподілу. Однак системі бракує інтеграції з чатами для полегшення комунікації.
	VolunteerMatch: сайт, який допомагає організувати волонтерську діяльність. Хоча цей сайт дозволяє спілкуватися між волонтерами та постраждалими, але його здатність на розподіл завдань обмежена.
	GivePulse: платформа для управління волонтерськими організаціями. Додаток є інструментом для створення волонтерських подій та відслідковування активності. 
Наша система буде виділятися такими особливостями:
	Підтримка різних платформ: можливість роботи на різних пристроях.
	Дистанційне керування та моніторинг: здійснення контролю за процесами та отримання даних незалежно від місця знаходження.
	Інтеграція з різними організаціями: можливість інтеграції з волонтерськими організаціями, які вже існують.


1.1.2 Бізнес-цілі та критерії успіху


BO-1: Успішний запуск продукту на ринку і створення бази клієнтів.
SC-1: За перші шість місяців досягти стабільного росту користувачів, збільшуючи кількість реєстрацій щомісяця на 5%.
BO-2: Створення довіри до продукту та аудиторії.
SC-2: Забезпечити ріст кількості активних користувачів на 7% кожного кварталу.
BO-3: Підвищення впізнаваності бренду.
SC-3: Розширити популярність у соціальних мережах, а також збільшити взаємодію з користувачами на 10% протягом першого року.
BO-4: Залучення інвестицій для подальшого розвитку.
SC-4: Отримати фінансування від інвесторів у такому розмірі, які допоможуть покрити витрати на наступний рік.
BO-5: Підвищення ефективності роботи волонтерських організацій.
SC-5: Знизити час на виконання завдань на 25% завдяки програмних процесів.
 
1.1.3 Потреби клієнтів та ринку


а) Потреби клієнтів: У системі для оптимізації роботи волонтерських організацій можна виділити кілька категорій користувачів:
	волонтери: Люди, які бажають допомагати в надзвичайних ситуаціях і шукають легкий метод отримати завдання відповідно до їхніх навичок. Їм потрібен інтерфейс, де вони матимуть змогу бачити всі свої завдання, отримувати сповіщення про нові завдання або зміни, мати можливість зв'язатися з постраждалими.
	Постраждалі: Люди, яким необхідно допомога під час кризових ситуацій, матимуть змогу легко подати запит на допомогу та відстежити його статус. Обов’язково система повинна забезпечити зручний інтерфейс для подачі запитів та отримання інформації про надання допомоги.
	Координаційні центри: Організації, які керують волонтерами та координують їхню діяльність. Вони вимагають ефективних засобів для управління завданнями, аналізу ефективності для кращої координації.
б) Ринковий попит: Попит на ці системи зростає через систематичні кризові ситуації та важливість ефективної координації дій. Ринок вимагає рішень, які задовільнять швидкий обмін інформацією, контроль процесів управління завданнями та моніторинг завдань.
в) Невиконані потреби: Основна частина вже існуючих програмних систем не дають змогу автоматизованого розподілу завдань та моніторингу їх виконання
г) Сценарії використання
	Для координаційного центру:
Опис: Координаційні центри контролюють завдання, які необхідно виконати волонтерам, відсліжують їх статус, параметри, наприклад: місцезнаходження та необхідні навички. Вони розподіляють ці завдання серед волонтерів та відстежують їхній прогрес.
Приклад: Центр відслідковує завдання у певному захопленому військовому місті. Система автоматично знаходить волонтерів у відповідній зоні та призначає їх на виконання завдання. Координаційний центр може в реальному часі бачити статус виконання завдань та маніпулювати ним.
	Для постраждалих:
Опис: Постраждалі мають можливість подати запити за допомогою зручного інтерфейсу, вказати свої потреби та місцезнаходження. Система обробить цей запити та призначить відповідних волонтерів для надання допомоги.
Приклад: Людина, яка потребує медичної допомоги під час землетрусу, подає запит через веб-інтерфейс. Програма знайде волонтерів в цій місцевості з медичною освітою та призначить їх для виконання цього завдання. Волонтер в чаті може запевнити людино, що допомого вже в дорозі.
	Для волонтерів:
Опис: Волонтери можуть бачити список доступних завдань, також відмітити статус їх виконання та описувати їх.
Приклад: Волонтер, зареєструвавшись у системі, отримує нове завдання у своєму районі. Він приймає завдання та може відповісти на повідомлення, тим самим уточнити всю необхідну інформацію дистанційно, волонтер доставляє всі обговорені ресурси до місця призначення та через додаток додає статус завдання як виконане, додаючи коментар.
 
1.1.4 Бізнес-ризики


Низька зацікавленість волонтерів у використанні системи
Ризик: Волонтери можуть не виявити достатньої зацікавленості у використанні нової системи через складність навчання або незрозумілий інтерфейс.
Рішення: Забезпечення легкого, зрозумілого в користуванні інтерфейсу та швидкого зворотного зв'язку від координаційного центру.
Відсутність фінансування на розвиток та підтримку системи
Ризик: Недостатнє фінансування може вплинути на такий фактор, як оновлення системи, що призведе до її технічного старіння.
Рішення: Залучення багатьох інвесторів для розвитку проекту. Розробка бізнес-моделей, які допоможуть в майбутньому отримати дохід від партнерів.
Безпека та конфіденційність даних
Ризик: Можливість витоку особистих даних волонтерів та постраждалих, що може призвести до юридичних наслідків та втрати довіри користувачів.
Рішення: Впровадження сучасних методів захисту даних та шифрування. 


1.2 Концепція рішення
1.2.1 Окреслення концепції


Програмна система спрямований на автоматизацію процесів управління волонтерськими організаціями у кризових ситуаціях. Основна мета - забезпечити ефективне керування завданнями, комунікацію та моніторинг ресурсів за допомогою сучасних технологій.
Ця система розрахована на те, щоб автоматично розподіляти завдання серед волонтерів, зменшуючи необхідність у ручному керуванні. 
Таким чином, створення цієї системи сприятиме підвищенню ефективності роботи волонтерських організацій та забезпеченню своєчасної допомоги постраждалим. 


1.2.2 Головна функціональність


MF1. Автоматизоване керування завданнями
Система дозволяє автоматично розподіляти завдання серед волонтерів:
	Аналіз місцезнаходження та навичок волонтерів.
	Призначення завдань відповідно до пріоритетів та ресурсів.
MF2. Моніторинг та звітність
Система надає можливість моніторити виконання завдань у реальному часі:
	Відстеження прогресу завдань.
	Сповіщення про зміни у статусі завдань.
MF3. Комунікаційний модуль
Інтеграція з різними засобами комунікації для покращення взаємодії:
	Вбудований чат для волонтерів та координаційних центрів.
MF4. Аналітика даних
Збір та аналіз даних для покращення ефективності роботи:
	Інструменти для аналізу ефективності волонтерів та завдань.
MF5. Управління ресурсами
Керування та моніторинг ресурсів, необхідних для виконання завдань:
	Відстеження наявності та використання ресурсів.
	Сповіщення про потребу у додаткових ресурсах.
MF6. Користувацькі профілі
Зручні та персоналізовані профілі для користувачів:
	Можливість налаштування профілю для зберігання особистої інформації та історії завдань.
MF7. Підтримка мов
Система підтримує дві мови для зручності користувачів:
	українська
	англійська


1.2.3 Припущення та залежності


П-1: Зростаюча потреба у цифрових рішеннях для кризового управління:
	Ефективність та швидкість: Волонтерські організації потребують інструментів, які допоможуть швидко реагувати на кризові ситуації та координувати завдання.
	Доступність інформації: Учасники волонтерських програм хочуть мати доступ до актуальних даних про завдання, ресурси та їх статус.
	Інтеграція з сучасними засобами комунікації: Необхідність у платформах, що підтримують сучасні засоби комунікації для швидкого обміну інформацією.
П-2: Технічні вимоги до системи:
	Стабільність та надійність: Система повинна бути стійкою до збоїв та мати механізми для швидкого відновлення.
	Мінімальні вимоги до обладнання: Система повинна працювати на стандартному обладнанні, доступному більшості користувачів.
	Легка інтеграція: Повинна забезпечувати легку інтеграцію з існуючими платформами та системами, які використовуються волонтерськими організаціями.

З-1: Інфраструктурні обмеження:
	Залежність від електропостачання: Для функціонування системи необхідне стабільне електропостачання. Перебої в електропостачанні можуть вплинути на доступність системи.
	Залежність від інтернет-з'єднання: Система потребує стабільного інтернет-з'єднання для доступу до серверів та обміну даними.
З-2: Залежність від нормативних вимог:
	Правове регулювання: Діяльність волонтерських організацій має відповідати місцевим та міжнародним законодавчим нормам.
	Захист персональних даних: Система повинна забезпечувати високий рівень захисту даних користувачів відповідно до регуляторних вимог.
З-3: Підтримка з боку організацій:	
	Залучення організацій: Успіх впровадження системи залежить від готовності волонтерських організацій використовувати нові технології та процеси.
	Навчання та адаптація: Організації повинні бути готовими до навчання своїх членів використанню нової системи та адаптації до змін.
 
1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Серверна частина:
	керування обліковими записами: реалізація механізму реєстрації та авторизації користувачів з ролями волонтера, координатора та постраждалого та керування правами доступу на основі ролей.
	управління завданнями: створення та редагування завдань координаторами та автоматичний розподіл завдань серед волонтерів на основі їх навичок та місцезнаходження.
	моніторинг виконання завдань: відстеження та сповіщення про зміну статусу завдань та критичні події.
Вебсайт:
	інтерфейс для волонтерів: перегляд та фільтрація доступних завдань, відмітка про виконання завдань та додавання коментарів.
	інтерфейс для координаційного центру: панель управління для створення, редагування та моніторингу завдань, інструменти для аналізу даних та генерації звітів.
	інтерфейс для постраждалих: форма подачі запитів на допомогу та відстеження статусу запитів.


1.3.2 Рамки наступних випусків


Серверна частина:
	розширене управління користувачами: впровадження двофакторної аутентифікації для підвищення безпеки, можливість додавання різних рівнів доступу для більш детального контролю прав користувачів.
	аналітика та звітність: покращені інструменти для аналізу даних, зокрема інтерактивні дашборди та можливість експортувати дані у різні формати, впровадження модулів для прогнозування та моделювання на основі зібраних даних.
	підтримка додаткових мов: додавання підтримки нових мов для забезпечення міжнародної доступності системи.
Вебсайт:
	покращений інтерфейс для користувачів: оптимізація інтерфейсу для кращої зручності використання на різних пристроях, впровадження персоналізованих дашбордів для кожної ролі (волонтер, постраждалий).
	соціальні функції: можливість створення груп волонтерів для спільного виконання завдань. Функціонал для обміну досвідом та порадами між волонтерами через форуми та блоги.
	розширені опції сповіщень: можливість налаштування сповіщень відповідно до уподобань користувачів (електронна пошта, SMS, месенджери).


1.3.3 Обмеження та винятки


Обмеження: Потреба у стабільному джерелі електроенергії для неперервної роботи системи.
Виняток: В систему включено акумулятор або генератор для забезпечення роботи у випадку надзвичайних ситуацій.
Обмеження: Обмежена кількість одночасних запитів до серверу.
Виняток: Поступове впровадження оптимізацій для підвищення продуктивності під час пікових навантажень.
Обмеження: Початкова підтримка обмеженої кількості мов інтерфейсу.
Виняток: Додавання нових мов та локальних налаштувань у майбутніх оновленнях для підтримки більшої кількості користувачів.
Обмеження: Відсутність можливості дистанційного оновлення програмного забезпечення пристроїв.
Виняток: Розробка процедури для ручного оновлення програмного забезпечення та впровадження функції віддаленого оновлення в майбутніх версіях.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


На таблиці 1.1 описані профілі зацікавлених сторін:

Таблиця 1.1 – Профілі зацікавлених сторін 
Зацікавлена сторона	Основна цінність	Ставлення	Основний інтерес	Обмеження
Волонтери	Простота використання системи, зручність виконання завдань	Очікування простоти інтерфейсу та готовність допомагати	Можливість допомогти людям	Складність в пристосуванні до нового інтерфейсу.
Координаційні центри	Оптимізація координації та розподілу завдань	Очікування полегшеного координування, зосередженість на результаті	Підвищення ефективності роботи, зменшення часу на управління	Обмежені ресурси для навчання персоналу та впровадження системи
Постраждалі	Отримання своєчасної та ефективної допомоги	Очікування швидкого на надійної допомоги	Можливість легко подавати запити на допомогу та відстежувати їх статус	Обмежений доступ до технологій або інтернету в кризових ситуаціях
Інвестори	Прибуток від інвестицій	Очікування високого фінансового та довгострокового прибутку	Отримати значних прибутків або хоча б повернути кошти	Обмеження бюджету, необхідність доведення проекту до релізу

 
1.4.2 Пріоритети проєкту


На таблиці 1.2 наведені основні пріорітети проєкту:

Таблиця 1.2 – Основні пріорітети проєкту 
Показник	Опис	Пріорітет
Графік виконання	Завершити основні етапи розробки 15.06.2024 для підготовки до версії 1.0.	Високий
Функціональність	Включити всі основні функції: керування завданнями, моніторинг ресурсів, комунікації та подача запитів.	Високий
Надійність	Програмна система повинна працювати без перебоїв та багів.	Високий
Командні можливості	Забезпечити достатню кількість ресурсів для всіх етапів розробки.	Середній
Бюджет	Укластися в запланований бюджет, але допукається перевищення від 5% до 10%	Середній


1.4.3 Робоче середовище


У робочому середовищі основні технології представлені наступним чином:
	Мова програмування: використання JavaScript з TypeScript забезпечує строгий контроль типів, що підвищує надійність і зручність у розробці як на фронтенді, так і на бекенді.
	База даних: Prisma ORM використовується для спрощення роботи з даними та забезпечення високої продуктивності. Prisma підтримує різні бази даних, і в цьому випадку обрана база даних MySQL, яка забезпечує надійне зберігання даних і підтримку шифрування та аутентифікації
	Фреймворк: використовуєтся NestJS фреймворк для Node.js для для серверної частини, який дозволяє створювати ефективні та швидкі серверні додатки.
	Користувацький інтерфейс: Для створення інтерфейсу користувача використовується бібліотека React з використанням Next.js. React дозволяє створювати інтерактивні та динамічні веб-сторінки. Для анімацій використовується Framer Motion.
	Забезпечення безпеки: для захисту даних під час передачі використовується протокол HTTPS. Аутентифікація та авторизація користувачів здійснюється за допомогою JWT, що гарантує захист.
 
2 ПОСТАНОВКА ЗАДАЧІ


Згідно аналізу предметної області, завданням курсової роботи є створення програмної системи для оптимізації роботи волонтерських організацій у кризових ситуаціях.
База даних повинна включати інформацію про: користувачів, ролі, завдання, ресурси, місця.
Для волонтерів:
	Реєстрація та вхід: волонтери можуть створювати облікові записи та входити в систему.
	Перегляд та вибір завдань: переглядати доступні завдання, фільтрувати їх за місцем та навичками.
	Відмітка про виконання: відмічати завдання як виконані.
	Сповіщення: отримувати сповіщення про нові завдання.
	Комунікація: спілкуватися з волонтерами та постраждалими через вбудований чат.
Для постраждалих:
	Подання запитів на допомогу: постраждалі можуть подавати запити на допомогу.
	Відстеження статусу: відстежувати статус своїх запитів.
	Сповіщення: отримувати сповіщення про надання допомоги.
Для координаційних центрів:
	Створення та редагування завдань: координатори можуть створювати, редагувати та видаляти завдання.
	Автоматичний розподіл завдань: автоматичний розподіл завдань серед волонтерів на основі їх місцезнаходження.
	Моніторинг: відстежувати виконання завдань у реальному часі.
	Управління профілями: Керувати профілями користувачів.
	Аналітика та звітність: Використовувати інструменти для створення звітів.
Підтримка локалізації та інтернаціоналізації:
	Підтримка різних мов інтерфейсу.
	Різні кодові таблиці символів.
	Формати дати та часу, місцевий та універсальний час.
	Підтримка метричних та імперських одиниць вимірювання.
 
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


На основі побудованої теми та аналізу предметної області було розроблено ER-діаграму 

 
Рисунок 3.1 – ER-діаграма

Користувач: таблиця, яка містить усю інформацію про користувачів, таких, як адміністратор, волонтер та постраждалі. Вона поєднується за допомогою зв’язків «один-до-багатьох» із таблицею Заява, «багато-до-багатьох» з Кваліфікація та Відділ.
	Відділ: таблиця, яка містить назву відділу, його опис та номер телефон. Вона поєднується за допомогою зв’язків «один-до-багатьох» із таблицею Ресурс та Заява, та «багато-до-багатьох» з таблицею Користувач.
	Заява: таблиця, яка містить тему заяви, текст, статус, відгук та місто постраждалого. Вона поєднується за допомогою зв’язків «один-до-багатьох» з таблицею Користувач та Відділ.
	Кваліфікація: таблиця, які містить назву кваліфікації та опис. Вона поєднується за допомогою зв’язку «багато-до-багатьох» із таблицею Користувач.
	Ресурс: таблиця, яка містить назву ресурсу та його кількість. Вона поєднується за допомогою зв’язків «один-до-багатьох» з таблицею Відділ та ТипРесурсу.


3.2 Побудова логічної моделі бази даних на основі ER-діаграми


Нормалізація бази даних досить важливий процес побудови, тому потрібно позбавитися зв’язків «багато-до-багатьох» між таблицями. Зробимо таблиці в яких будуть зв’язки тільки «один-до-одного» та «один-до-багатьох»

Таким чином, у цій моделі бази даних будуть включені такі таблиці:
	жертви (Victims);
	заяви (Statements);
	повідомлення_заяви (StatementMessages);
	відділи (Departments);
	волонтери (Volunteers);
	кваліфікації (Qualifications);
	волонтер_кваліфікації (VolunteerQualifications);
	волонтер_відділ (VolunteerDepartments);
	ресурси (Resources);
	типи_ресурсів (ResourceTypes);
	відділ_ресурси (DepartmentResources);
	адміністратори (Administrators);
	адміністратори_відділ (AdministratorDepartments);
	користувачі (Users).

1.	Таблиця жертви (Victims)
Таблиця буде включати такі атрибутами:
	victimId (первинний ключ);
	name;
	surname;
	gender;
	dateOfBirth;
	phoneNumber.
Проведемо аналіз таблиці Victims на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа;
2.	Таблиця заяв (Statements)
Таблиця буде включати такі атрибутами:
	statementId (первинний ключ);
	victimId (зовнішній ключ);
	departmentId (зовнішній ключ);
	topic;
	text;
	status;
	feedback.
Проведемо аналіз таблиці Statements на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа;
3.	Таблиця повідомлень заяв (StatementMessages)
Таблиця буде включати такі атрибутами:
	messageId (первинний ключ);
	statementId (зовнішній ключ);
	text.
Проведемо аналіз таблиці StatementMessages на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа;
4.	Таблиця відділів (Departments)
Таблиця буде включати такі атрибутами:
	departmentId (первинний ключ);
	name;
	description;
	phoneNumber.
Проведемо аналіз таблиці Departments на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа;
5.	Таблиця волонтерів (Volunteers)
Таблиця буде включати такі атрибутами:
	volunteerId (первинний ключ);
	userId (зовнішній ключ);
	name;
	surname;
	gender;
	dateOfBirth;
	phoneNumber.
Проведемо аналіз таблиці Volunteers на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа;
6.	Таблиця кваліфікацій (Qualifications)
Таблиця буде включати такі атрибутами:
	qualificationId (первинний ключ);
	nameOfQualification;
	description.
Проведемо аналіз таблиці Qualifications на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа;
7.	Таблиця кваліфікацій волонтерів (VolunteerQualifications)
Таблиця буде включати такі атрибутами:
	olunteerQualificationId (первинний ключ);
	volunteerId (зовнішній ключ);
	qualificationId (зовнішній ключ).
Проведемо аналіз таблиці VolunteerQualifications на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа;
8.	Таблиця відділ волонтерів (VolunteerDepartments)
Таблиця буде включати такі атрибутами:
	volunteerDepartmentId (первинний ключ);
	volunteerId (зовнішній ключ);
	departmentId (зовнішній ключ).
Проведемо аналіз таблиці VolunteerDepartments на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа.
9.	Таблиця ресурсів (Resources)
Таблиця буде включати такі атрибутами:
	resourceId (первинний ключ);
	nameOfResource;
	typeOfResourceId (зовнішній ключ);
	numberOfResources.
Проведемо аналіз таблиці Resources на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа.
10.	Таблиця типів ресурсів (ResourceTypes)
Таблиця буде включати такі атрибутами:
	typeOfResourceId (первинний ключ);
	nameOfType;
	description.
Проведемо аналіз таблиці ResourceTypes на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа.
11.	Таблиця відділ ресурсів (DepartmentResources)
Таблиця буде включати такі атрибутами:
	departmentResourceId (первинний ключ);
	resourceId (зовнішній ключ);
	departmentId (зовнішній ключ).
Проведемо аналіз таблиці DepartmentResources на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа.
12.	Таблиця адміністраторів (Administrators)
Таблиця буде включати такі атрибутами:
	adminId (первинний ключ);
	name;
	surname;
	gender;
	phoneNumber.
Проведемо аналіз таблиці Administrators на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа.
13.	Таблиця адміністраторів відділ (AdministratorDepartments)
Таблиця буде включати такі атрибутами:
	adminDepartmentId (первинний ключ);
	adminId (зовнішній ключ);
	departmentId (зовнішній ключ).
Проведемо аналіз таблиці AdministratorDepartments на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа.
14.	Таблиця користувачів (Users)
Таблиця буде включати такі атрибутами:
	userId (первинний ключ);
	email;
	name;
	surname;
	role.
Проведемо аналіз таблиці Users на нормалізацію:
	кожен атрибут у таблиці містить лише одне значення, тому є атомарними;
	дані в таблиці організовані таким чином, що не дублюються, а всі зайві атрибути винесені в окремі таблиці;
	кожен атрибут, що не є ключевим залежить лише від первинного ключа.

 
Рисунок 3.2 – Схема бази даних

Оскільки всі таблиці відповідають третій нормальній формі, тоді слід зазначити, що й вся база даних задовольняє вимогам третьої нормальної форми.
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


У цій системі використовується 3 типа користувачі (див. рис. 4.1):
	Постраждалі
	Волонтери
	Координаційний центр
Головні функції постраждалих:
Створення запитів:
	POST /statement
Перегляд своїх запитів:
	GET /statement  для перегляду всіх заяв.
	GET /statement/:id – для перегляду конкретної заяви.
Отримання повідомленя:
	GET /statement-message/:id
Видаляти свої запити:
	DELETE /statement/:id
Головні функції волонтерів:
Перегляд запитів, що належать до його відділу та міста:
	GET /statement?view=VOLUNTEER&userId=:id
Додавання повідомлення до запитів:
	POST /statement-message
Створення, оновлення та видалення інформації:
	POST /volunteer — створення волонтера;
	PUT /volunteer/:id — оновлення інформації про волонтера;
	DELETE /volunteer/:id — видалення волонтера.
Перегляд кваліфікації:
	GET /qualification
Головні функції координаційних центрів:
Управління користувачами:
	GET /user — перегляд всіх користувачів.
	POST /user — створення нового користувача.
	PUT /user/:id — оновлення інформації про користувача.
	DELETE /user/:id — видалення користувача
Управління відділами:
	POST /department — створення відділу.
	PUT /department/:id — оновлення відділу.
	DELETE /department/:id — видалення відділу.
Управління ресурсами:
	GET /resource — перегляд всіх ресурсів.
	POST /resource — створення нового ресурсу.
	PUT /resource/:id — оновлення ресурсу.
	DELETE /resource/:id — видалення ресурсу.
Управління типами ресурсів:
	GET /type-of-resource — перегляд всіх типів ресурсів.
	POST /type-of-resource — створення нового типу ресурсу.
	PUT /type-of-resource/:id — оновлення типу ресурсу.
	DELETE /type-of-resource/:id — видалення типу ресурсу.
Управління кваліфікаціями:
	GET /qualification — перегляд всіх кваліфікацій.
	POST /qualification — створення нової кваліфікації.
	PUT /qualification/:id — оновлення кваліфікації.
	DELETE /qualification/:id — видалення кваліфікації.
Управління запитами:
	GET /statement
	DELETE /statement/:id

 
Рисунок 4.1 – UML-діаграма серверної частини

Розробка серверної частина побудована на Node.js, а саме за допомогою фреймворку NestJs. Використовується MySQL, як система керування базою даних, доступ до якої здійснюється через серверний додаток за допомогою Prisma. Цей додаток надає легкий та ефективний спосіб обробки. Тому Prisma дозволяє просто використовувати дані в Node.js та NestJs надаючи дані у вигляді об'єктів (див. рис. 4.2).

 
Рисунок 4.2 – UML-діаграма розгортання

Дані передаються за допомогою безпечного протоколу HTTPS, що гарантує захист і конфіденційність даних при передачі. Серверний додаток створений за основами модульної архітектури, яку надає NestJS. Він побудований у вигляді окремих модулів, що забезпечують роботу різних функціональних частин, а саме авторизація, управління користувачами, волонтерами, постраждалими та інше. Це дає можливість зберігати зрозумілу та чітку структуру та додає гнучкості системи.
На діаграмі пакеті можна детально зобразити побудову серверного додатку (див. рис. 4.3).
 
Рисунок 4.3 – UML-діаграма пакетів

Для хешування використовується bcrypt, а для реалізації автентифікації та авторизації – JWT. Ці технології дають безпечне управління користувачами та досить високу гнучкість.


4.2 Архітектура клієнтської частини


Це програмна система побудована на трьох видах акторів, такі як: постраждалий, волонтер та координаційний центр. 
Відповідно інтересів та запитів волонтерів програмна система буде включати: 
	Створення профілю;
	Список локальних завдань з можливістю їх перегляду, видаленням, сортуванням та фільтрацією;
	Прийняття завдання та відміну по завершенню з додавання коментарю;
	Відстеження статусу виконання завдання, а саме прогресу та оновлення;
	Зворотній зв’язок з постраждалим за допомогою вбудованого чату для комунікації;
	Доступ до таблиці з ресурсами з можливістю перегляду та видаленням ресурсів.
До інтересів постраждалих належать: 
	Створення профілю;
	Створення, редагування та видалення запиту на допомогу з можливістю вказанням теми, обставин, вказанням міста та потреб допомоги;
	Відстеження статусу завдання з можливістю перегляду стану підтвердження, очікування, зупинки чи завершення;
	Зворотній зв’язок з волонтерами за допомогою вбудованого чату для комунікації;
	Підтримка локалізації для зміни мови.
До запитів адміністраторів належать:
	Управління користувачами з можливістю перегляду, створення, редагування, надавання необхідних властивостей та видалення облікових записів;
	Керування доступу та ролей;
	Створення масових завдань з розподілом їх за місцезнаходженням;
	Перегляд, зміна, видалення та керування запитів постраждалих;
	Перегляд, редагування, додавання нового відділу та закріплення за волонтером конкретного відділу;
	Перегляд та створення звітів виконаної роботи та її ефективності;
	Керування ресурсами з можливістю додаванням, видаленням та відслідковуванням їх кількості 
	Керування кваліфікаціями з можливістю додавати, редагувати, видаляти їх та закріплювати за конкретним волонтером.
	Зворотній зв’язок з волонтерами та постраждалими за допомогою вбудованого чату для комунікації в кожному запиті (див. рис. 4.4.1   4.4.2).

 
Рисунок 4.4.1 – UML-діаграма клієнтської частини
 Рисунок 4.4.2 – UML-діаграма клієнтської частини
Розробка клієнтської частина побудована на Next.js. Це сучасний та досить потужний JavaScript-фреймворк, який побудований на основі React. 
Мовою програмування було обрано TypeScript для зручності розробки та типізації. 
NextUI – бібліотека для дизайну сайту, яка використовується для швидкого створення досить гарних інтерфейсів. 
Tailwind CSS   для створення привабливого дизайну через утилітарні CSS класи.
HTTP-запити виконувалися за допомогою JavaScript бібліотеки Axios. Вона дозволить легко налаштовувати асинхронні запити, включаючи встановлення заголовків, обробку помилок та інше.
React Toastify використовується для показу повідомлень користувачам. Він дозволяє інформувати про успішні дії або помилки, що виникають під час виконання операцій.
Роботу з формами допомагала виконувати бібліотека Formik у поєднанні з Yup, яка забезпечувала зручну валідацію даних.
Управління станом системи та кешування запитів було виконано за допомогою бібліотеки React Query. 
Збірка клієнтської частини була виконана за допомогою Next.js, адже це фреймворк має вбудовану систему збірки, яка автоматично виконує схожі дії з Webpack.
На діаграмі пакеті можна детально роздивитися побудову клієнтської частини (див. рис. 4.5).

 
Рисунок 4.5 – UML-діаграма пакетів клієнтської частини

Клієнтська частина програмної системи поділена на кілька функціональних модулів. У ній кожен шар відповідає за окремі елементи застосунку. Ця система розподіляє обов'язків між компонентами та надає модульність.
Модуль app: Містить сторінки застосунку та компоненти. Сторінки мають підрозділи administrators, departments, qualifications тощо, вони відповідають за певну функціональність. Вони також містять сторінки для авторизація, а саме login та signup.
Модуль components: Містить компоненти інтерфейсу, наприклад, chat, sidebar, table тощо. Вони використовуються в різних частинах системи для побудови інтерфейсу користувача.
Модуль constants: Зберігає постійні значення, які використовуються в прорграмі, такі як налаштування або фіксовані дані, що потрібні для логіки.
Модуль dto: Відповідає за об’єкти передачі даних, організовані у підрозділи для кожної функціональної частини, наприклад, для запитів та відповідей, що забезпечують передачу даних між клієнтом та сервером.
Модуль hooks: Включає кастомні хуки React, що використовуються для керування станом та іншими операціями в компонентах.
Модуль interfaces: Включає визначення інтерфейсів та типів для TypeScript, які використовуються у різних частинах застосунку, зокрема у backend, frontend, та інших частинах проєкту.
Модуль routes: Містить логіку маршрутизації застосунку, включаючи налаштування API маршрутів та стандартних шляхів для навігації.
Модуль services: Містить файли, відповідальні за взаємодію з сервером та API, тут знаходяться модулі для роботи з HTTP-запитами (axios) та обробки даних з сервера.
Модуль styles: Відповідає за стилізацію компонентів та сторінок додатку. Містить файли CSS та стилі для налаштування візуальної частини інтерфейсу.
Модуль utils: Включає утиліти та допоміжні функції, що спрощують виконання поширених операцій у програмі.
 
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження


Для того, що розпочати роботу з програмною системою потрібно спочатку завантажити архів та розпакувати його. Потрім необхідно програму MAMP, адже ця система використовує СУБД MySQL, тому потрібно зайти на офіційний сайт та натиснути кнопку Завантажити. Після завантаження необхідно запустити сервер. 
Для того, щоб під’єднати базу даних до нашої програмної системи потрібно завантажити кодовий редактор Visual Studio Code та перенести папку volonteer-app та volunteer-backend. Далі зайти до папки volunteer-backend відкрити термінал та написати команду npm i; prisma migrate dev -name "initial"; npm run start:dev.

 
Рисунок 5.1 – Встановлення та запуск серверної частини

Для налаштування клієнтської частини потрібно створити новий термінал, зайти до папки volonteer-app та ввести команди npm i; npm run build; npm start.

 
Рисунок 5.2 – Встановлення та запуск клієнтської частини
 
5.2 Логічна структура програмної системи


Авторизація та реєстрація – це частина системи містить функціонал для входу в особистий профіль. Користувач вводить свої дані email та пароль та має можливість зайти до системи, якщо ж облікового запису не оснує, то користувач переходить до реєстрації та вводить свої особисті дані та має можливість зареєструватися як волонтер або постраждалий.
Заяви – це частина, яка містить усі запити постраждалих. У цьому просторі є таблиця та деякі кнопки, де користувач може відредагувати певний запит та зробити новий. Також відкрити внутрішній чат для комунікації та додати нові необхідні дані.
Ресурси – це частина де волонтер та адміністратор можуть переглядати назву ресурсу, його тип та кількість, змінювати та створювати нові ресурси.
Тип ресурсів – це частина інтерфейсу, де користувач може переглядати назву типу та його опис для більш детального розуміння, редагувати його та створювати.
Користувачі, волонтери, адміністратори та постраждалі – це розділи, до яких мають доступ тільки адміністратори. У цих частинах можна переглядати, створювати та редагувати інформацію про всіх типів користувачів.
Відділ – це розділ, де адміністратор має право переглядати назви відділів, опис, номер телефону відділу та його ресурси, редагувати їх та додавати нові. 
Кваліфікація – розділ, в якому адміністратор має можливість переглядати назви кваліфікації та їх опис, змінювати та створювати нові.
 
5.3 Опис користувацького інтерфейсу


Після того, як користувач запустить систему, в нього відкриється сторінка з авторизацією користувача, де він матиме змогу ввести свої вже зареєстровані дані, а саме пошту та пароль. Якщо облікового запису ще не існує, користувач має перейти до сторінки реєстрації (див. рис. 5.3   5.4).

 
Рисунок 5.3 – Сторінка авторизації

Під час реєстрації користувач може ввести ім'я, прізвище, стать, електронну пошту, пароль, підтвердження паролю та вибрати роль: волонтер або постраждалий, якщо роль волонтера, то відкривається нове поле, де можна обрати місто.

 
Рисунок 5.4 – Сторінка реєстрації

Після реєстрації волонтери та постраждалі опиняються на сторінці запитів постраждалих, де можна переглядати, створювати, редагувати запити та переходити до різних сторінок. Адміністратор та волонтер також мають зробити звіт виконаних робіт за весь час (див рис. 5.5).

 
Рисунок 5.5 – Сторінка запитів

Якщо постраждалий захоче надіслати повідомлення, то на вкладці запитів він має натиснути на значок чату та перейти до сторінки чату, де він матиме можливість комунікувати (див. рис. 5.6).

 
Рисунок 5.6 – Сторінка чату

Волонтер та адміністратор мають можливість перейти до вкладки ресурсів. Тут вони можуть переглянути назву, опис та кількість ресурсів, якщо ресурси закінчуються, то він починає світитися жовтим. Також на вкладці ресурсів можна редагувати та додавати нові дані, але для цього повинен вже бути створений тип ресурсу адміністратором (див. рис. 5.7).

 
Рисунок 5.7 – Сторінка ресурсів

Можливості адміністратора, а саме координаційних центрів набагато більші. При входженні до обліково запису адміністратор опиняється на сторінці користувачів, де він матиме змогу переглядати та створювати нових користувачів та додавати їм роль, також редагувати їх та видаляти (див. рис. 5.8).

 
Рисунок 5.8 – Сторінка користувачів

Далі адміністратор може перейти до вкладки адміністраторів, де він матиме можливість назначати нових адміністраторів, вказувати їх ім’я, прізвище, номер телефону, стать та вказувати до якого саме відділу вони будуть відноситися (див. рис. 5.9).
 
Рисунок 5.9 – Сторінка адміністраторів

Наступна сторінка волонтерів, де адміністратор матиме можливість додати нового волонтера, вказати їх ім’я, прізвище, номер телефону, кваліфікацію, відділ, стать, дату народження та місто, редагувати, переглянути їх дані та видалити (див. рис. 5.10).

 
Рисунок 5.10 – Сторінка волонтерів

На сторінці постраждалих адміністратор можна переглянути список користувачів, які зареєстровані в системі, редагувати та видаляти та додавати імя, прізвище, стать, дату народження та номер телефону (див. рис. 5.11).

 
Рисунок 5.11 – Сторінка постраждалих

На сторінці відділів адміністратор має можливість редагувати новий відділ, видалити його та створити новий. Додати адміністратор може в ці дані назву відділу, опис, номер телефону та ресурси, які будуть належати до цього відділу, але для цього їх потрібно створити на сторінці ресурсів (див. рис. 5.12).

 
Рисунок 5.12 – Сторінка відділів

На сторінці типів ресурсів адміністратор може переглянути, редагувати, видалити та створити новий тип для того, щоб ці дані можна було використовувати для створення та угрупування різних ресурсів (див.рис. 5.13).

 
Рисунок 5.13 – Сторінка типів ресурсів

Кваліфікації – це сторінка, де адміністратор може переглянути, редагувати, видалити та створити нову кваліфікацію для волонтерів та відділів. Адміністратор може додати назву кваліфікації та її опис (див. рис. 5.14).

 
Рисунок 5.14 – Сторінка кваліфікацій

Користувачі, які не розуміють української мови, мають змогу легко перемикнути мови на будь-якій сторінці у верхньому лівому кутку навігаційного меню (див. рис. 5.15 – 5.16). Всього доступно дві мови: англійська та українська.

 
Рисунок 5.15 – Сторінка з українською мовою

 
Рисунок 5.16 – Сторінка з англійською мовою

Отже, була розроблена та описана програмна система, яка допомагає роботі волонтерським організаціям у кризових ситуаціях. Відеозапис роботи програмної системи доступний за посиланням: https://youtu.be/o1NGg7op5CE (дата зверенення: 15.06.2024).
 
ВИСНОВКИ


У результаті виконаної курсової роботи була розроблена програмна система, що оптимізує роботу волонтерських організацій під час кризових ситуацій. Основною метою було автоматизувати ключові процеси управління завданнями, координацію між волонтерами та постраждалими, а також адміністрування ресурсів.
У ході роботи було виконано аналіз предметної області, спроектовано базу даних та розроблено архітектуру системи, яка складається з трьох основних компонентів: серверної частини, клієнтської частини та бази даних. Система побудована на сучасних технологіях: серверна частина реалізована за допомогою Node.js з використанням фреймворку NestJS, клієнтська частина на базі Next.js, а база даних управляється за допомогою MySQL.
Розроблена система дозволяє ефективно розподіляти завдання між волонтерами на основі їх навичок та місцезнаходження, моніторити виконання завдань у реальному часі, управляти користувачами, відділами, ресурсами та кваліфікаціями. Вбудований чат для комунікації полегшує взаємодію між волонтерами та постраждалими, забезпечуючи швидкий обмін повідомленнями. Крім того, система підтримує багатомовний інтерфейс та має гнучку архітектуру, що дозволяє масштабувати її для використання у різних організаціях.
Програмна система відповідає усім вимогам та задачам, зазначеним у курсовій роботі, та може бути використана для покращення координації волонтерських організацій у складних кризових ситуаціях.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	NestJS - A progressive Node.js framework. NestJS - A progressive Node.js framework. URL: https://nestjs.com/ (дата звернення: 15.06.2024).
2.	Docs | Next.js. Next.js by Vercel - The React Framework. URL: https://nextjs.org/docs (дата звернення: 15.06.2024).
3.	Axios Docs. Axios. URL: https://axios-http.com/uk/docs/intro (дата звернення: 15.0.2024).
4.	JWT.IO - JSON Web Tokens Introduction. JSON Web Tokens - jwt.io. URL: https://jwt.io/introduction (дата звернення: 15.06.2024).
5.	Learn how to build applications with Prisma | Prisma. Prisma. URL: https://www.prisma.io/learn (дата звернення: 15.06.2024).
6.	The starting point for learning TypeScript. TypeScript: JavaScript With Syntax For Types. URL: https://www.typescriptlang.org/docs/ (дата звернення: 15.06.2024).
7.	Introduction | Framer for Developers. The web builder for stunning sites. URL: https://www.framer.com/motion/introduction/ (дата звернення: 15.06.2024).
 
ДОДАТОК A
Код серверної частини
А.1 Код administrator.controller
import {
	Body,
	Controller,
	Delete,
	Get,
	Param,
	ParseIntPipe,
	Post,
	Put,
	UseInterceptors,
	UsePipes,
	ValidationPipe,
} from '@nestjs/common';
import { AdministratorService } from './administrator.service';
import { ApiResponseCompleteOperationInterceptor } from '../../common/interceptors/response/completeOperation.response.interceptor';
import { CreateOrUpdateAdministratorRequestDto } from './dto/request/CreateOrUpdateAdministrator.request.dto';

@Controller('administrator')
export class AdministratorController {
	constructor(private readonly administratorService: AdministratorService) {}

	@UseInterceptors(ApiResponseCompleteOperationInterceptor)
	@Get('/')
	async getAdministrators() {
		return await this.administratorService.getAdministrators();
	}

	@UseInterceptors(ApiResponseCompleteOperationInterceptor)
	@UsePipes(new ValidationPipe())
	@Post('/')
	async createAdministrator(@Body() dto: CreateOrUpdateAdministratorRequestDto) {
		return await this.administratorService.createAdministrator(dto);
	}

	@UseInterceptors(ApiResponseCompleteOperationInterceptor)
	@UsePipes(new ValidationPipe())
	@Put('/:id')
	async updateAdministrator(
		@Param('id', ParseIntPipe) adminId: number,
		@Body() dto: CreateOrUpdateAdministratorRequestDto,
	) {
		return await this.administratorService.updateAdministrator(adminId, dto);
	}

	@UseInterceptors(ApiResponseCompleteOperationInterceptor)
	@Delete('/:id')
	async deleteAdministrator(@Param('id', ParseIntPipe) adminId: number) {
		return await this.administratorService.deleteAdministrator(adminId);
	}
}

А.2 Код administrator.module

import { Module } from '@nestjs/common';
import { AdministratorService } from './administrator.service';
import { AdministratorController } from './administrator.controller';
import { DatabaseModule } from '../../database/database.module';

@Module({
	imports: [DatabaseModule],
	providers: [AdministratorService],
	controllers: [AdministratorController],
})
export class AdministratorModule {}

А.3 Код administrator.service

import { Injectable } from '@nestjs/common';
import { DatabaseService } from '../../database/database.service';
import { GetAdministratorResponseDto } from './dto/response/GetAdministrator.response.dto';
import { CreateOrUpdateAdministratorRequestDto } from './dto/request/CreateOrUpdateAdministrator.request.dto';

@Injectable()
export class AdministratorService {
	constructor(private readonly databaseService: DatabaseService) {}

	async getAdministrators(): Promise<GetAdministratorResponseDto[]> {
		return await this.databaseService.administrator.findMany({
			include: {
				user: true,
				AdministratorDepartment: {
					include: {
						department: true,
					},
				},
			},
		});
	}

	async createAdministrator(dto: CreateOrUpdateAdministratorRequestDto): Promise<GetAdministratorResponseDto> {
		const AdministratorDepartment = dto.departmentIds
			? dto.departmentIds.map((department) => {
					return {
						departmentId: Number(department),
					};
			  })
			: [];

		return await this.databaseService.administrator.create({
			data: {
				userId: dto.userId,
				AdministratorDepartment: {
					create: AdministratorDepartment,
				},
				name: dto.name,
				surname: dto.surname,
				gender: dto.gender,
				dateOfBirth: dto.dateOfBirth,
				phoneNumber: dto.phoneNumber,
			},
			include: {
				user: true,
				AdministratorDepartment: {
					include: {
						department: true,
					},
				},
			},
		});
	}

	async updateAdministrator(
		adminId: number,
		dto: CreateOrUpdateAdministratorRequestDto,
	): Promise<GetAdministratorResponseDto> {
		const AdministratorDepartment = dto.departmentIds
			? dto.departmentIds.map((department) => {
					return {
						departmentId: Number(department),
					};
			  })
			: [];

		return await this.databaseService.administrator.update({
			where: { adminId },
			data: {
				userId: dto.userId,
				AdministratorDepartment: {
					deleteMany: {},
					create: AdministratorDepartment,
				},
				name: dto.name,
				surname: dto.surname,
				gender: dto.gender,
				dateOfBirth: dto.dateOfBirth,
				phoneNumber: dto.phoneNumber,
			},
			include: {
				user: true,
				AdministratorDepartment: {
					include: {
						department: true,
					},
				},
			},
		});
	}

	async deleteAdministrator(adminId: number): Promise<GetAdministratorResponseDto> {
		return await this.databaseService.administrator.delete({
			where: { adminId },
			include: {
				user: true,
				AdministratorDepartment: {
					include: {
						department: true,
					},
				},
			},
		});
	}
}

А.4 Код auth.controller

import { Body, Controller, HttpCode, Post, UseInterceptors, UsePipes, ValidationPipe } from '@nestjs/common';
import { AuthService } from './auth.service';
import { ApiResponseCompleteOperationInterceptor } from '../../common/interceptors/response/completeOperation.response.interceptor';
import { LogInRequestDto } from './dto/request/LogIn.request.dto';
import { Public } from '../../common/decorators/public.decorator';
import { SignUpRequestDto } from './dto/request/SignUp.request.dto';

@Controller('auth')
export class AuthController {
	constructor(private readonly authService: AuthService) {}

	@Public()
	@UseInterceptors(ApiResponseCompleteOperationInterceptor)
	@UsePipes(new ValidationPipe())
	@HttpCode(200)
	@Post('login')
	async logIn(@Body() dto: LogInRequestDto) {
		return await this.authService.logIn(dto);
	}

	@Public()
	@UseInterceptors(ApiResponseCompleteOperationInterceptor)
	@UsePipes(new ValidationPipe())
	@Post('signup')
	async signUp(@Body() dto: SignUpRequestDto) {
		const res = await this.authService.signUp(dto);
		console.log(res);
		return res;
	}
}
 
А.5 Код auth.guard

import { CanActivate, ExecutionContext, Headers, Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Reflector } from '@nestjs/core';
import * as process from 'node:process';
import { IS_PUBLIC_KEY } from '../../common/decorators/public.decorator';

interface AuthRequestHeaders extends Headers {
	authorization: string;
}

@Injectable()
export class AuthGuard implements CanActivate {
	constructor(private jwtService: JwtService, private reflector: Reflector) {}

	async canActivate(context: ExecutionContext): Promise<boolean> {
		const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
			context.getHandler(),
			context.getClass(),
		]);

		if (isPublic) return true;

		const request = context.switchToHttp().getRequest();

		const token = this.extractTokenFromHeader(request);

		if (!token) throw new UnauthorizedException();

		try {
			request['user'] = await this.jwtService.verifyAsync(token, {
				secret: process.env.JWT_SECRET,
			});
		} catch {
			throw new UnauthorizedException();
		}

		return true;
	}

	private extractTokenFromHeader(request: Request): string | undefined {
		const [type, token] = (request.headers as AuthRequestHeaders).authorization?.split(' ') ?? [];

		return type === 'Bearer' ? token : undefined;
	}
}

А.6 Код auth.module

import { Module } from '@nestjs/common';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { JwtModule } from '@nestjs/jwt';
import { UserModule } from '../user/user.module';
import * as process from 'node:process';
import { DatabaseModule } from '../../database/database.module';

@Module({
	imports: [
		DatabaseModule,
		UserModule,
		JwtModule.register({
			global: true,
			secret: process.env.JWT_SECRET,
			signOptions: { expiresIn: '1d' },
		}),
	],
	controllers: [AuthController],
	providers: [AuthService],
	exports: [AuthService],
})
export class AuthModule {}

А.7 Код auth.sevice

import { BadRequestException, HttpException, HttpStatus, Injectable, UnauthorizedException } from '@nestjs/common';
import { UserService } from '../user/user.service';
import { LogInRequestDto } from './dto/request/LogIn.request.dto';
import { LogInResponseDto } from './dto/response/LogIn.response.dto';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { SignUpRequestDto } from './dto/request/SignUp.request.dto';
import { RoleEnum } from '@prisma/client';
import { DatabaseService } from '../../database/database.service';
import * as process from 'node:process';

@Injectable()
export class AuthService {
	constructor(
		private userService: UserService,
		private jwtService: JwtService,
		private databaseService: DatabaseService,
	) {}

	async logIn(dto: LogInRequestDto): Promise<LogInResponseDto> {
		const findUser = await this.userService.getUser(dto.email);

		if (!findUser.length) throw new HttpException('Not found user', HttpStatus.NOT_FOUND);

		const user = findUser[0];

		const isPasswordMatch = await bcrypt.compare(dto.password, user.password);

		if (!isPasswordMatch) {
			throw new HttpException('Password not match', HttpStatus.BAD_REQUEST);
		}

		const payload = { userId: user.userId, email: user.email, role: user.role };

		return {
			access_token: await this.jwtService.signAsync(payload),
		};
	}

	async signUp(dto: SignUpRequestDto) {
		const SALT_ROUNDS = process.env.SALT_ROUNDS ? Number(process.env.SALT_ROUNDS) : 10;

		const user = {
			email: dto.email,
			password: await bcrypt.hash(dto.password, SALT_ROUNDS),
			role: dto.role,
		};

		const entity = {
			name: dto.name,
			surname: dto.surname,
			dateOfBirth: dto.dateOfBirth,
			gender: dto.gender,
			city: dto.city ? dto.city : null,
		};

		return this.databaseService.$transaction(async (tx) => {
			const findUser = await tx.user.findFirst({
				where: { email: user.email },
			});

			if (findUser) throw new HttpException('User with this email already exist', HttpStatus.BAD_REQUEST);

			const newUser = await tx.user.create({
				data: user,
			});

			if (dto.role === RoleEnum.VICTIM) {
				await tx.victim.create({
					data: {
						userId: newUser.userId,
						...entity,
					},
				});
			} else if (dto.role === RoleEnum.VOLUNTEER) {
				await tx.volunteer.create({
					data: {
						userId: newUser.userId,
						...entity,
					},
				});
			}

			const payload = { userId: newUser.userId, email: newUser.email, role: newUser.role };

			return {
				access_token: await this.jwtService.signAsync(payload),
			};
		});
	}
}

 
ДОДАТОК Б
Код клієнтської частини

Б.1 Код login
'use client';

// NEXTJS
import Link from 'next/link';

// NEXTUI
import { Button, Input } from '@nextui-org/react';

// FORMIK
import { Formik, Form } from 'formik';

// FRAMER MOTION
import { motion } from 'framer-motion';

// DTO
import { LogInRequestDto } from '@/dto/request/login/LogIn.request.dto';

// SCHEMA
import { LoginSchema } from '@/app/[locale]/login/Login.schema';

// ICONS
import { IconKey, IconLogin, IconMedicalCross } from '@tabler/icons-react';

// INTERFACES
import { JSX } from 'react';
import { useLogInMutation } from '@/hooks/auth/auth.hook';
import { NestedKeyOf, useTranslations } from 'next-intl';

// INIT VALUES
const INITIAL_VALUES: LogInRequestDto = {
	email: '',
	password: '',
};

const Login = (): JSX.Element => {
	const t = useTranslations();
	const loginMutation = useLogInMutation();

	const submitHandler = async (values: LogInRequestDto): Promise<void> => {
		await loginMutation.mutateAsync(values);
	};

	return (
		<div className="w-screen h-screen flex items-center justify-center">
			<Formik initialValues={INITIAL_VALUES} onSubmit={submitHandler} validationSchema={LoginSchema}>
				{({ values, errors, setFieldValue, handleSubmit }) => (
					<Form className="w-full" onSubmit={handleSubmit}>
						<div className="w-full flex justify-center items-center">
							<div className="w-1/4 flex flex-col gap-4 justify-center items-center">
								<motion.div
									className="flex flex-row gap-2 justify-center items-center"
									initial={{ opacity: 0, scale: 0.5 }}
									animate={{ opacity: 1, scale: 1 }}
									transition={{
										duration: 0.8,
										delay: 0.5,
										ease: [0, 0.71, 0.2, 1.01],
									}}
								>
									<h1 className="text-2xl font-semibold">{t('Volunteer app' as NestedKeyOf<any>)}</h1>
									<div>
										<Button isIconOnly color="danger" variant="flat">
											<IconMedicalCross size={20} />
										</Button>
									</div>
								</motion.div>
								<Input
									isRequired
									label={t('Email' as NestedKeyOf<any>)}
									variant="bordered"
									size="sm"
									value={values.email}
									onValueChange={(value) => setFieldValue('email', value)}
									isInvalid={!!errors.email}
									errorMessage={errors.email as string}
								/>
								<Input
									isRequired
									type="password"
									label={t('Password' as NestedKeyOf<any>)}
									variant="bordered"
									size="sm"
									value={values.password || ''}
									onValueChange={(value) => setFieldValue('password', value)}
									isInvalid={!!errors.password}
									errorMessage={errors.password as string}
								/>
								<Button className="w-full" color="primary" type="submit" startContent={<IconLogin size={18} />}>
									{t('Log In' as NestedKeyOf<any>)}
								</Button>
								<Button
									href="/signup"
									className="w-full"
									color="primary"
									variant="flat"
									as={Link}
									startContent={<IconKey size={18} />}
								>
									{t('Sign Up' as NestedKeyOf<any>)}
								</Button>
							</div>
						</div>
					</Form>
				)}
			</Formik>
		</div>
	);
};

export default Login;

Б.2 Код signup

'use client';

// NEXTJS
import Link from 'next/link';

// NEXTUI
import { Button, Input, Select, SelectItem } from '@nextui-org/react';

// FORMIK
import { Form, Formik } from 'formik';

// FRAMER MOTION
import { motion } from 'framer-motion';

// DTO
import { SignUpRequestDto } from '@/dto/request/signup/SignUp.request.dto';

// SCHEMA
import { SignUpSchema } from '@/app/[locale]/signup/SignUp.schema';

// MUTATION
import { useSignUpMutation } from '@/hooks/auth/auth.hook';

// ICONS
import { IconKey, IconLogin, IconMedicalCross } from '@tabler/icons-react';

// INTERFACES
import { JSX } from 'react';
import { RoleEnum } from '@/interfaces/backend/enum/role.enum';
import { GenderEnum } from '@/interfaces/backend/enum/gender.enum';
import { NestedKeyOf, useTranslations } from 'next-intl';

// INIT VALUES
const INITIAL_VALUES: SignUpRequestDto = {
	name: '',
	surname: '',
	dateOfBirth: null,
	gender: GenderEnum.MALE,
	email: '',
	password: '',
	confirmPassword: '',
	role: RoleEnum.VICTIM,
	city: undefined,
};

const SignUp = (): JSX.Element => {
	const t = useTranslations();
	const signupMutation = useSignUpMutation();

	const submitHandler = async (values: SignUpRequestDto): Promise<void> => {
		values.dateOfBirth = values.dateOfBirth ? new Date(values.dateOfBirth).toISOString() : null;

		await signupMutation.mutateAsync(values);
	};

	return (
		<div className="w-screen h-screen flex items-center justify-center">
			<Formik initialValues={INITIAL_VALUES} onSubmit={submitHandler} validationSchema={SignUpSchema}>
				{({ values, errors, setFieldValue, handleSubmit }) => (
					<Form className="w-full" onSubmit={handleSubmit}>
						<div className="w-full flex justify-center items-center">
							<div className="w-1/4 flex flex-col gap-4 justify-center items-center">
								<motion.div
									className="flex flex-row gap-2 justify-center items-center"
									initial={{ opacity: 0, scale: 0.5 }}
									animate={{ opacity: 1, scale: 1 }}
									transition={{
										duration: 0.8,
										delay: 0.5,
										ease: [0, 0.71, 0.2, 1.01],
									}}
								>
									<h1 className="text-2xl font-semibold">{t('Volunteer app' as NestedKeyOf<any>)}</h1>
									<div>
										<Button isIconOnly color="danger" variant="flat">
											<IconMedicalCross size={20} />
										</Button>
									</div>
								</motion.div>
								<Input
									label={t('Name' as NestedKeyOf<any>)}
									variant="bordered"
									size="sm"
									isRequired
									value={values.name}
									onValueChange={(value) => setFieldValue('name', value)}
									isInvalid={!!errors.name}
									errorMessage={errors.name as string}
								/>
								<Input
									label={t('Surname' as NestedKeyOf<any>)}
									variant="bordered"
									size="sm"
									isRequired
									value={values.surname}
									onValueChange={(value) => setFieldValue('surname', value)}
									isInvalid={!!errors.surname}
									errorMessage={errors.surname as string}
								/>
								<Input
									type="date"
									label={t('Date of birth' as NestedKeyOf<any>)}
									variant="bordered"
									size="sm"
									value={values.dateOfBirth || ''}
									onValueChange={(value) => setFieldValue('dateOfBirth', value)}
									isInvalid={!!errors.dateOfBirth}
									errorMessage={errors.dateOfBirth as string}
								/>
								<Select
									isRequired
									label={t('Gender' as NestedKeyOf<any>)}
									variant="bordered"
									size="sm"
									classNames={{ value: 'text-inherit' }}
									value={values.gender}
									defaultSelectedKeys={[GenderEnum.MALE]}
									onChange={({ target }) => setFieldValue('gender', target.value)}
									isInvalid={!!errors.gender}
									errorMessage={errors.gender as string}
								>
									<SelectItem key="MALE">{t('Male' as NestedKeyOf<any>)}</SelectItem>
									<SelectItem key="FEMALE">{t('Female' as NestedKeyOf<any>)}</SelectItem>
								</Select>
								<Input
									isRequired
									autoComplete="off"
									label={t('Email' as NestedKeyOf<any>)}
									variant="bordered"
									size="sm"
									value={values.email}
									onValueChange={(value) => setFieldValue('email', value)}
									isInvalid={!!errors.email}
									errorMessage={errors.email as string}
								/>
								<Input
									isRequired
									autoComplete="off"
									type="password"
									label={t('Password' as NestedKeyOf<any>)}
									variant="bordered"
									size="sm"
									value={values.password || ''}
									onValueChange={(value) => setFieldValue('password', value)}
									isInvalid={!!errors.password}
									errorMessage={errors.password as string}
								/>
								<Input
									isRequired
									autoComplete="off"
									type="password"
									label={t('Confirm password' as NestedKeyOf<any>)}
									variant="bordered"
									size="sm"
									value={values.confirmPassword}
									onValueChange={(value) => setFieldValue('confirmPassword', value)}
									isInvalid={!!errors.confirmPassword}
									errorMessage={errors.confirmPassword as string}
								/>
								<Select
									isRequired
									label={t('Role' as NestedKeyOf<any>)}
									variant="bordered"
									size="sm"
									classNames={{ value: 'text-inherit' }}
									value={values.role}
									onChange={({ target }) => setFieldValue('role', target.value)}
									isInvalid={!!errors.role}
									errorMessage={errors.role as string}
								>
									<SelectItem key="VICTIM">{t('Victim' as NestedKeyOf<any>)}</SelectItem>
									<SelectItem key="VOLUNTEER">{t('Volunteer' as NestedKeyOf<any>)}</SelectItem>
								</Select>
								{values.role === RoleEnum.VOLUNTEER ? (
									<Input
										label={t('City' as NestedKeyOf<any>)}
										variant="bordered"
										size="sm"
										isRequired
										value={values.city || ''}
										onValueChange={(value) => setFieldValue('city', value)}
										isInvalid={!!errors.city}
										errorMessage={errors.city as string}
									/>
								) : null}
								<Button className="w-full" color="primary" type="submit" startContent={<IconKey size={18} />}>
									{t('Sign Up' as NestedKeyOf<any>)}
								</Button>
								<Button
									href="/login"
									className="w-full"
									color="primary"
									variant="flat"
									as={Link}
									startContent={<IconLogin size={18} />}
								>
									{t('Log In' as NestedKeyOf<any>)}
								</Button>
							</div>
						</div>
					</Form>
				)}
			</Formik>
		</div>
	);
};

export default SignUp;

Б.3 Statement 

'use client';

// NEXTUI
import {
	BreadcrumbItem,
	Breadcrumbs,
	Button,
	Select,
	Selection,
	SelectItem,
	SortDescriptor,
	Table,
	TableBody,
	TableCell,
	TableColumn,
	TableHeader,
	TableRow,
} from '@nextui-org/react';

// CONSTANTS
import { STATEMENT_TABLE_COLUMNS } from '@/constants/table/tableColumns/statement.columns';
import { TABLE_EMPTY_CONTENT } from '@/constants/table/table.constants';

// MODALS
import CreateStatementModal from '@/app/[locale]/(pages)/statements/modal/createStatement/CreateStatement.modal';
import UpdateStatementModal from '@/app/[locale]/(pages)/statements/modal/updateStatement/UpdateStatement.modal';

// RENDER CELL
import { statementTableRenderCell } from '@/app/[locale]/(pages)/statements/table/StatementTableRenderCell';

// ICONS
import { IconDownload, IconFileInvoice, IconHome } from '@tabler/icons-react';

// INTERFACES
import { GetStatementResponseDto } from '@/dto/response/statement/GetStatement.response.dto';
import { ChangeEvent, JSX, useMemo, useState } from 'react';
import { useGetStatementsQuery } from '@/hooks/statement/statement.hook';
import { getCookie } from 'cookies-next';
import { ACCESS_TOKEN_KEY } from '@/constants/jwt.constant';
import { AccessTokenPayload } from '@/middleware';
import { jwtDecode } from 'jwt-decode';
import { ColumnSortUtils } from '@/utils/sort/ColumnSort.utils';
import { StatementStatusEnum } from '@/interfaces/backend/enum/statementStatus.enum';
import { fileSystemService } from '@/services/axios/fileSystem/fileSystem.service';
import { useTranslations, NestedKeyOf } from 'next-intl';

const Statements = (): JSX.Element => {
	const t = useTranslations();
	const ACCESS_TOKEN = getCookie(ACCESS_TOKEN_KEY) || '';
	const payload: AccessTokenPayload = jwtDecode(ACCESS_TOKEN);

	const statements = useGetStatementsQuery({
		view: payload.role,
		userId: payload.userId,
	});

	const [sortDescriptor, setSortDescriptor] = useState<SortDescriptor>({});
	const [selectedStatement, setSelectedStatement] = useState<Selection>(new Set());
	const [selectedStatus, setSelectedStatus] = useState<StatementStatusEnum | 'ALL'>('ALL');

	const sortedData = useMemo(() => {
		const responseData = statements.data?.data || [];
		const resultData =
			selectedStatus === 'ALL'
				? responseData
				: responseData.filter((statement: GetStatementResponseDto) => statement.status === selectedStatus);

		return ColumnSortUtils<GetStatementResponseDto>(resultData, sortDescriptor);
	}, [sortDescriptor, statements, selectedStatus]);

	return (
		<div className="h-full flex flex-col gap-4">
			<div>
				<Breadcrumbs>
					<BreadcrumbItem startContent={<IconHome size={18} />}>{t('Home' as NestedKeyOf<any>)}</BreadcrumbItem>
					<BreadcrumbItem startContent={<IconFileInvoice size={18} />}>{t('Statements' as NestedKeyOf<any>)}</BreadcrumbItem>
				</Breadcrumbs>
			</div>
			<div className="flex flex-row gap-2">
				<CreateStatementModal />
				<UpdateStatementModal statementId={selectedStatement} />
				<Select
					aria-label="Choose statement status"
					className="flex-1"
					style={{ width: '100px' }}
					disallowEmptySelection={true}
					selectionMode="single"
					defaultSelectedKeys={['ALL']}
					onChange={(event: ChangeEvent<HTMLSelectElement>) => {
						if (event.target.value === '') return;
						setSelectedStatus(event.target.value as StatementStatusEnum | 'ALL');
					}}
				>
					<SelectItem key="ALL">{t('All' as NestedKeyOf<any>)}</SelectItem>
					<SelectItem key={StatementStatusEnum.OPEN}>{t('Open' as NestedKeyOf<any>)}</SelectItem>
					<SelectItem key={StatementStatusEnum.PROCESS}>{t('Process' as NestedKeyOf<any>)}</SelectItem>
					<SelectItem key={StatementStatusEnum.PAUSED}>{t('Paused' as NestedKeyOf<any>)}</SelectItem>
					<SelectItem key={StatementStatusEnum.CLOSED}>{t('Closed' as NestedKeyOf<any>)}</SelectItem>
				</Select>
				<Button
					className="text-white"
					color="success"
					startContent={<IconDownload size={18} />}
					onPress={() => fileSystemService.getStatementReport()}
				>
					{t('Download report' as NestedKeyOf<any>)}
				</Button>
			</div>
			<Table
				className="h-full"
				aria-label="Dynamic statement table"
				selectionMode="single"
				sortDescriptor={sortDescriptor}
				onSortChange={setSortDescriptor}
				onSelectionChange={(value) => setSelectedStatement(value)}
				isStriped
			>
				<TableHeader columns={STATEMENT_TABLE_COLUMNS}>
					{(column) => (
						<TableColumn key={column.key} allowsSorting={column.sortable}>
							{t(column.label)}
						</TableColumn>
					)}
				</TableHeader>
				<TableBody items={sortedData} emptyContent={TABLE_EMPTY_CONTENT}>
					{(row: GetStatementResponseDto) => (
						<TableRow key={row.statementId}>
							{(columnKey) => <TableCell>{statementTableRenderCell(row, columnKey)}</TableCell>}
						</TableRow>
					)}
				</TableBody>
			</Table>
		</div>
	);
};

export default Statements;

Б.4 Код user

'use client';

// NEXTUI
import {
	BreadcrumbItem,
	Breadcrumbs,
	Button,
	SelectedItemProps,
	SortDescriptor,
	Table,
	TableBody,
	TableCell,
	TableColumn,
	TableHeader,
	TableRow,
} from '@nextui-org/react';

// MODALS
import CreateUserModal from '@/app/[locale]/(pages)/users/modal/createUser/CreateUser.modal';
import UpdateUserModal from '@/app/[locale]/(pages)/users/modal/updateUser/UpdateUser.modal';

// ICONS
import { IconHome, IconUsers } from '@tabler/icons-react';

// RENDER CELL
import { userTableRenderCell } from '@/app/[locale]/(pages)/users/table/UserTableRenderCell';

// INTERFACES
import { Selection } from '@nextui-org/react';
import { GetUserResponseDto } from '@/dto/response/user/GetUser.response.dto';
import { JSX, useMemo, useState } from 'react';

// CONSTANTS
import { USER_TABLE_COLUMNS } from '@/constants/table/tableColumns/user.columns';
import { TABLE_EMPTY_CONTENT } from '@/constants/table/table.constants';

// HOOKS
import { useGetUsersQuery } from '@/hooks/user/user.hook';

// UTILS
import { ColumnSortUtils } from '@/utils/sort/ColumnSort.utils';
import {NestedKeyOf, useTranslations} from "next-intl";

const Users = (): JSX.Element => {
	const t = useTranslations();

	const users = useGetUsersQuery();

	const [sortDescriptor, setSortDescriptor] = useState<SortDescriptor>({});
	const [selectedUser, setSelectedUser] = useState<Selection>(new Set());

	const sortedData = useMemo(() => {
		return ColumnSortUtils<GetUserResponseDto>(users.data?.data || [], sortDescriptor);
	}, [sortDescriptor, users]);

	return (
		<div className="h-full flex flex-col gap-4">
			<div>
				<Breadcrumbs>
					<BreadcrumbItem startContent={<IconHome size={18} />}>{t('Home' as NestedKeyOf<any>)}</BreadcrumbItem>
					<BreadcrumbItem startContent={<IconUsers size={18} />}>{t('Users' as NestedKeyOf<any>)}</BreadcrumbItem>
				</Breadcrumbs>
			</div>
			<div className="flex flex-row gap-2">
				<CreateUserModal />
				<UpdateUserModal userId={selectedUser} />
			</div>
			<Table
				className="h-full"
				aria-label="Dynamic user table"
				selectionMode="single"
				sortDescriptor={sortDescriptor}
				onSortChange={setSortDescriptor}
				onSelectionChange={(value) => setSelectedUser(value)}
				isStriped
			>
				<TableHeader columns={USER_TABLE_COLUMNS}>
					{(column) => (
						<TableColumn key={column.key} allowsSorting={column.sortable}>
							{t(column.label)}
						</TableColumn>
					)}
				</TableHeader>
				<TableBody items={sortedData} emptyContent={TABLE_EMPTY_CONTENT}>
					{(row: GetUserResponseDto) => (
						<TableRow key={row.userId}>{(columnKey) => <TableCell>{userTableRenderCell(row, columnKey)}</TableCell>}</TableRow>
					)}
				</TableBody>
			</Table>
		</div>
	);
};

export default Users;

Б.5 Код chat

'use client';

// HOOK
// INTERFACES
import { JSX, useState } from 'react';

// COMPONENTS
import { Button } from '@nextui-org/react';

// HOOK
import { useCreateStatementMessageMutation } from '@/hooks/statementMessage/statementMessage.hook';

// CONSTANTS
import { CHAT_MESSAGE_LIMIT } from '@/constants/chat/chat.constants';

// ICONS
import { IconSend } from '@tabler/icons-react';

// DTO
import { CreateOrUpdateStatementMessageRequestDto } from '@/dto/request/statementMessage/CreateOrUpdateStatementMessage.request.dto';
import { jwtDecode } from 'jwt-decode';
import { getCookie } from 'cookies-next';
import { ACCESS_TOKEN_KEY } from '@/constants/jwt.constant';
import { AccessTokenPayload } from '@/middleware';
import { RoleEnum } from '@/interfaces/backend/enum/role.enum';

interface ChatControllersProps {
	statementId: string;
}

const ChatControllers = ({ statementId }: ChatControllersProps): JSX.Element => {
	const ACCESS_TOKEN = getCookie(ACCESS_TOKEN_KEY) || '';
	const payload: AccessTokenPayload = jwtDecode(ACCESS_TOKEN);

	const createMessage = useCreateStatementMessageMutation();

	const [message, setMessage] = useState<string | null>('');

	const sendMessageHandler = async () => {
		const chatInputController = document.getElementById('chat-controllers__input-message');

		if (!chatInputController || !message) return;

		const statementMessage: CreateOrUpdateStatementMessageRequestDto = {
			statementId: Number(statementId),
			text: message,
			isVictim: payload.role === RoleEnum.VICTIM,
		};

		await createMessage.mutateAsync(statementMessage);
		setMessage('');
		chatInputController.textContent = '';
	};

	return (
		<div className="chat-controllers-container">
			<div className="chat-controllers__send-message-container">
				<div className="chat-controllers__input-container">
					<div className="chat-controllers__input-content">
						<div
							id="chat-controllers__input-message"
							className="chat-controllers__input-message"
							data-placeholder="Type a message..."
							contentEditable
							onInput={(event) => setMessage((event.target as HTMLDivElement).textContent)}
						/>
					</div>
				</div>
				<Button
					className="chat-controllers__send-button"
					color="primary"
					size="lg"
					isIconOnly
					isDisabled={!message?.length || message.length > 200}
					onPress={sendMessageHandler}
				>
					<IconSend />
				</Button>
			</div>
			<div className="chat-controllers__text-limit">
				{message?.length} / {CHAT_MESSAGE_LIMIT}
			</div>
		</div>
	);
};

export default ChatControllers;

'use client';

// COMPONENTS

// INTERFACES
import { GetStatementMessageResponseDto } from '@/dto/response/statementMessage/GetStatementMessage.response.dto';
import { JSX } from 'react';
import { IVictim } from '@/interfaces/backend/entity/victim.interface';
import { getCookie } from 'cookies-next';
import { ACCESS_TOKEN_KEY } from '@/constants/jwt.constant';
import { AccessTokenPayload } from '@/middleware';
import { jwtDecode } from 'jwt-decode';
import { RoleEnum } from '@/interfaces/backend/enum/role.enum';

interface ChatMessagesProps {
	messages: GetStatementMessageResponseDto[];
	victim: IVictim;
}

const ChatMessages = ({ messages, victim }: ChatMessagesProps): JSX.Element => {
	const ACCESS_TOKEN = getCookie(ACCESS_TOKEN_KEY) || '';
	const payload: AccessTokenPayload = jwtDecode(ACCESS_TOKEN);

	return (
		<div className="chat__messages-container">
			<div className="chat__messages">
				{messages.map((message) => (
					<div
						key={message.messageId}
						className="chat__message-container"
						data-victim={payload.role === RoleEnum.VICTIM ? !message.isVictim : message.isVictim}
					>
						<div className="chat__message">
							<div className="chat__message-content">
								<div className="chat__message-text-container">
									<span className="chat__message-username">
										{message.isVictim ? `${victim.name} ${victim.surname}` : 'System user'}
									</span>
									<span className="chat__message-text">{message.text}</span>
								</div>
								<div className="chat__message-status-container">
									<div className="chat__message-time-container">
										<span className="chat__message-time">{message.createdAt.split('T')[1].slice(0, 5)}</span>
									</div>
								</div>
							</div>
						</div>
					</div>
				))}
			</div>
		</div>
	);
};

export default ChatMessages;
